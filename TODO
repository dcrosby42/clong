  
  Augment timer system with "death-clock" 
    timer componet that counts down
    when ttl <= 0, the whole entity is removed from the manager
    Names: :pickup :trash :delete :death :death-clock :die :remove
    (once in place, could be used for all sorts of entity removal? [:remove {:ttl 0}]


  Once expiry is in place,
    convert update-explosions into particle-system 
    remove special code for expiring lasers and explosions
    Update scored-system to hinge on scored-timer presence, not the ttl
      let timer expiry do the work


  Catalog the systems/functions that reach "outside" the entities and use :meta


!!! BUGZ / ISSUES

- Red laser explosions are stood back from the green paddle on impact (since explosions are ignited at the upper-left of the laser box)
? scored-mode: timer cleanup?
? Applying the timer system in scored mode would increment ALL timer components in the manager

- Poisen paddles w slowness on laser impact
/ Collide lasers w paddles
/ Trigger explosion on impact

- Naming... :modes should be :mode-fn-sets or something.  An object like this should be called "mode-fns": { :in default-transition, :out (fn [m] ...), :update (fn [m d i] ...)}
- Append rendering systems per-mode?
/ :scored mode should persist for 1 second then transition automatically to :ready
/ :ready's in-fn should reset necessary state in the manager 
/ First-time game setup should honor and live by the in-fn for :ready
/ Fire lasers



Features:

- Light randomization of initial ball launch
- Light randomization of explosions
- Effect on paddle strike
- Effect on wall strike
- Effect on goal strike
/ Make lasers do something to ball
/ Fire lasers from paddles
/ Make lasers do something to enemy paddle
/ Delay ball instantiation and launch until Enter
/ Deflect off ceiling and floor
/ Count score when goal is struck
/ Display score counter
/ Pause on space

Tech:
- Bring "graph" plumbing library in?

--------------------
A refactoring
--------------------
Timers:
  timer-system / timer component was general and nice
  expire-lasers, expire-explosions: separate code to make timed-out items vanish
  scored-timer: very special handling being done.



OLD Smells from pre-ECS refactoring:
- UGH: fire laser
  Firing control knowledge is hiding inside update-paddle, but that function returns a paddle.  
  OPTION 1: set temp state on the paddle, indicating a laser should be fired, and rely on a subsequent function to:
    - detect the laser
    - add it to the appropriate lasers list in the game state
    - clear that temp state out of the paddle.
    X nasty?  This requires, eg, update-state-playing to weave a pipeline of paddle mods in its let statement.
    WENT WITH THIS OPTION
  
  OPTION 2: let something else detect the firing
    - DON'T do the detection / laser creation in update-paddle
    x ergh... the extraction of controls would be repeated outside the update-paddle func somewhere polluting.

  OPTION 3: update-paddle (and other similar funcs) return an updated target + side effects

- UGH! Laser / paddle collision detection and handling
  Lots of intertwined knowledge
  Had to update lots of other code (such as update-paddle) to accomodate the slow-down effect

- Paused and Ready state repeat the update-mode logic
- Paused/playing/ready updaters all call the same update-mode function, which then branches internally on state
  -> seems like there could be a more cause-effect relationship
- controller-mapping is a global valuer referenced from several tier2 update functions 

